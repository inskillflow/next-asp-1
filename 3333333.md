

# Phase 3 — Authentification & Autorisation dans Next.js (trois options)

## Rôles et contrôle d’accès (communs aux 3 options)

* **Rôles** : `Student`, `Instructor`, `Admin` (stockés en base via Prisma, ou portés en claims/jwt selon l’option).
* **Matrice d’accès** identique à ce qui a été défini (les endpoints “métier” restent les mêmes; ils deviennent protégés) :

| Ressource               | Méthode           | Accès requis                      |
| ----------------------- | ----------------- | --------------------------------- |
| `/api/courses`          | GET (liste, id)   | Authentifié (peu importe le rôle) |
| `/api/courses`          | POST, PUT         | `Instructor` ou `Admin`           |
| `/api/courses/{id}`     | DELETE            | `Admin`                           |
| `/api/instructors`      | GET (liste, id)   | Authentifié                       |
| `/api/instructors`      | POST, PUT, DELETE | `Admin`                           |
| `/api/students`         | GET (liste, id)   | Authentifié                       |
| `/api/students`         | POST              | `Instructor` ou `Admin`           |
| `/api/students/{id}`    | PUT, DELETE       | `Admin`                           |
| `/api/enrollments`      | GET (liste, id)   | Authentifié                       |
| `/api/enrollments`      | POST              | Authentifié                       |
| `/api/enrollments/{id}` | PUT               | `Instructor` ou `Admin`           |
| `/api/enrollments/{id}` | DELETE            | `Admin`                           |

> “Authentifié” = session valide (selon l’option). Répondre **401** si non authentifié, **403** si rôle insuffisant.

---

## Structure de protection (commune, adaptée par option)

* **Guard de route API** (par ressource) : dans chaque handler Next (ex. `app/api/courses/route.ts`), extraire l’identité (JWT/Clerk/NextAuth), **valider la session**, puis **vérifier le rôle** avant d’exécuter.
* **middleware.ts** (optionnel) : pour rejeter très tôt les requêtes non authentifiées sur des chemins sensibles, ou pour enrichir les headers côté serveur. Utile mais non obligatoire (les guards dans les handlers suffisent).

---

## Option A — JWT “maison” dans Next.js

### Vue d’ensemble

* Vous exposez **vos propres endpoints** d’auth Next (App Router) et gérez les **tokens** vous-même :

  * **Access Token** (court, ex. 15 min) en **cookie HttpOnly** (recommandé) ou en `Authorization: Bearer`
  * **Refresh Token** (long, ex. 7 jours) en **cookie HttpOnly** distinct
* Hash des mots de passe : **bcryptjs**.
* Sign JWT : **jose** (ou `jsonwebtoken`).
* Persistance utilisateurs/refresh tokens : **Prisma**.

### Dépendances

```
npm i bcryptjs jose zod
```

### Modèle Prisma minimal

* `User` (avec `role`)
* `RefreshToken` (token, userId, expiresAt, revokedAt)

### Endpoints d’auth (exhaustifs, sous `/app/api/auth/...`)

> Préfixe commun : `/api/auth`

| Endpoint    | Méthode | Requête (JSON)                                       | Réponse (200)                                             | Notes                                |
| ----------- | ------- | ---------------------------------------------------- | --------------------------------------------------------- | ------------------------------------ |
| `/register` | POST    | `{ username, email, password, firstName, lastName }` | `{ userId, username, email, role }`                       | 400 validation, 409 conflit          |
| `/login`    | POST    | `{ usernameOrEmail, password }`                      | `{ accessToken, expiresIn }` ou vide (si cookie HttpOnly) | place aussi `refreshToken` en cookie |
| `/refresh`  | POST    | — (utilise cookie `refreshToken`)                    | `{ accessToken, expiresIn }`                              | 401/409 si expiré/révoqué            |
| `/logout`   | POST    | —                                                    | `{ success:true }` + clear cookies                        | 401 si non auth                      |
| `/revoke`   | POST    | `{ refreshToken }` (ou prend cookie)                 | `{ success:true }`                                        | admin/self-revoke                    |
| `/validate` | POST    | — (lit access token cookie/Authorization)            | `{ valid, sub, email, role, exp }`                        | 401 si invalide                      |
| `/me`       | GET     | —                                                    | `{ id, username, email, role, firstName, lastName }`      | 401 si non auth                      |

**Cookies recommandés**

* `access_token` : HttpOnly, Secure, SameSite=Lax, `Max-Age=900`
* `refresh_token` : HttpOnly, Secure, SameSite=Strict, `Max-Age=604800`

**Exemple — signature et set-cookie (route `/login`)**

```ts
// app/api/auth/login/route.ts
import { NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import bcrypt from 'bcryptjs'
import { SignJWT } from 'jose'

const key = new TextEncoder().encode(process.env.JWT_SECRET!)
const ISSUER = 'EduTrackNext'
const AUDIENCE = 'EduTrackClients'

export async function POST(req: Request) {
  const { usernameOrEmail, password } = await req.json()

  const user = await prisma.user.findFirst({
    where: { OR: [{ email: usernameOrEmail }, { username: usernameOrEmail }] }
  })
  if (!user || !(await bcrypt.compare(password, user.passwordHash))) {
    return NextResponse.json({ error: 'Invalid credentials' }, { status: 401 })
  }

  const accessToken = await new SignJWT({
    sub: user.id,
    email: user.email,
    role: user.role
  })
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuer(ISSUER)
    .setAudience(AUDIENCE)
    .setIssuedAt()
    .setExpirationTime('15m')
    .sign(key)

  // Générer & persister refreshToken (opaque UUID) puis cookie
  const res = NextResponse.json({ accessToken, expiresIn: 900 })
  res.cookies.set('access_token', accessToken, { httpOnly: true, secure: true, sameSite: 'lax', maxAge: 900, path: '/' })
  // set refresh_token aussi...
  return res
}
```

**Guard d’accès (exemple dans un handler “métier”)**

```ts
// app/api/courses/route.ts (GET public-auth; POST require Instructor/Admin)
import { NextResponse } from 'next/server'
import { getUserFromRequest } from '@/lib/auth/jwt' // lit cookie ou header et vérifie le token

export async function GET() {
  const user = await getUserFromRequest() // 401 si absent/invalid
  // ... retourner la liste
  return NextResponse.json([])
}

export async function POST(req: Request) {
  const user = await getUserFromRequest()
  if (!['Instructor', 'Admin'].includes(user.role)) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
  }
  // ... créer le cours
  return NextResponse.json({ ok: true }, { status: 201 })
}
```

**Séquences (Mermaid) — Login → API → Refresh**

```mermaid
sequenceDiagram
  participant B as Browser
  participant Auth as /api/auth/*
  participant DB as Prisma (Users/RefreshTokens)
  participant S as API sécurisée

  B->>Auth: POST /login {usernameOrEmail, password}
  Auth->>DB: Vérifie user + bcrypt
  DB-->>Auth: OK
  Auth-->>B: 200 + Set-Cookie(access_token, refresh_token)

  B->>S: GET /api/courses (cookies envoyés)
  S-->>B: 200

  Note over B,Auth: Access expiré
  B->>Auth: POST /refresh (cookie refresh_token)
  Auth->>DB: Vérif refresh token
  Auth-->>B: 200 + nouveau access_token
```

**Décision d’autorisation**

```mermaid
flowchart TD
  A[Requête API] --> B{Access token valide ?}
  B -- Non --> E[401 Unauthorized]
  B -- Oui --> C{Rôle autorisé ?}
  C -- Non --> F[403 Forbidden]
  C -- Oui --> D[200 OK]
```

---

## Option B — Clerk pour Next.js

### Vue d’ensemble

* **Clerk** gère l’UI (Sign in/Sign up), MFA, providers.
* Dans l’API Next, on valide via le **SDK Clerk** (aucune route /login à coder).
* Les rôles peuvent être stockés dans **`publicMetadata.role`** chez Clerk et/ou synchronisés en base via **webhook**.

### Dépendances

```
npm i @clerk/nextjs
```

### Middleware Clerk

* `middleware.ts` (via `clerkMiddleware`) pour protéger des chemins par défaut (facultatif si vous gardez les guards dans les handlers).
* Exemple minimal :

```ts
// middleware.ts
import { clerkMiddleware } from '@clerk/nextjs/server'
export default clerkMiddleware()
export const config = { matcher: ['/((?!_next|.*\\..*).*)'] }
```

### Validation côté API (handlers)

* Dans vos routes App Router :

```ts
// app/api/courses/route.ts
import { auth, currentUser } from '@clerk/nextjs/server'
import { NextResponse } from 'next/server'

export async function GET() {
  const { userId } = auth() // 401 si absent
  // si besoin: const user = await currentUser(); const role = user?.publicMetadata?.role
  return NextResponse.json([])
}

export async function POST(req: Request) {
  const user = await currentUser()
  const role = user?.publicMetadata?.role
  if (role !== 'Instructor' && role !== 'Admin') {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
  }
  // créer le cours...
  return NextResponse.json({ ok: true }, { status: 201 })
}
```

### Endpoints d’auth côté Next (ce que vous exposez)

* **Vous n’exposez pas** `/api/auth/login` ni `/register`.
* Endpoints utiles côté backend :

  * `POST /api/auth/validate` : retourne les claims Clerk validés (utile pour debug/outillage)
  * `GET /api/auth/me` : retourne l’utilisateur courant (id, email, role) via `currentUser()`
  * `POST /api/webhooks/clerk` : **optionnel**, pour synchroniser user/role en base Prisma

### Séquences (Mermaid)

```mermaid
sequenceDiagram
  participant U as User (browser)
  participant CK as Clerk Hosted Pages
  participant API as Next API
  participant DB as Prisma (option synchro)

  U->>CK: SignIn/SignUp
  CK-->>U: Session/Token (géré par Clerk SDK)
  U->>API: POST /api/courses (Clerk auth envoyée)
  API->>CK: Vérifie session via SDK/JWKS (interne)
  API-->>U: 201 si role autorisé
```

---

## Option C — NextAuth (JWT ou session cookie)

### Vue d’ensemble

* **NextAuth** gère les providers (Credentials/OAuth), stocke session (cookie) et peut émettre un **JWT**.
* L’API Next lit la session via **`auth()`/`getServerSession`** dans les handlers ou **valide un JWT** si vous l’activez.

### Dépendances

```
npm i next-auth
```

### Route NextAuth

* App Router : `app/api/auth/[...nextauth]/route.ts` (config providers).
* **JWT mode** (recommandé pour APIs externes) : `session: { strategy: 'jwt' }`, callback `jwt` pour injecter `role`.

**Exemple (extrait)**

```ts
// app/api/auth/[...nextauth]/route.ts
import NextAuth from "next-auth"
import Credentials from "next-auth/providers/credentials"
import { prisma } from "@/lib/prisma"
import bcrypt from "bcryptjs"

const handler = NextAuth({
  session: { strategy: 'jwt' },
  providers: [
    Credentials({
      name: "Credentials",
      credentials: { username: {}, password: {} },
      async authorize(creds) {
        const user = await prisma.user.findFirst({
          where: { OR: [{ email: creds.username }, { username: creds.username }] }
        })
        if (!user) return null
        const ok = await bcrypt.compare(creds.password, user.passwordHash)
        return ok ? { id: user.id, email: user.email, role: user.role } : null
      }
    })
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) token.role = (user as any).role
      return token
    },
    async session({ session, token }) {
      if (token) (session as any).role = token.role
      return session
    }
  }
})

export { handler as GET, handler as POST }
```

### Utilisation dans vos handlers API

* **Cookie de session** (même origine) :

```ts
// app/api/enrollments/[id]/route.ts
import { auth } from "next-auth"
import { NextResponse } from "next/server"

export async function PUT(req: Request, { params }: { params: { id: string } }) {
  const session = await auth()
  if (!session) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  const role = (session as any).role
  if (role !== 'Instructor' && role !== 'Admin') {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
  }
  // ... update inscription / note
  return NextResponse.json({ ok: true })
}
```

* **JWT NextAuth** (si vous exposez un token pour clients externes) :

  * Ajoutez un mini-endpoint **`GET /api/auth/token`** qui retourne le JWT de session.
  * Côté API, lisez `Authorization: Bearer <jwt>` et vérifiez via la clé/secret NextAuth.

### Séquences (Mermaid)

```mermaid
sequenceDiagram
  participant U as User
  participant NA as NextAuth
  participant API as Next API

  U->>NA: POST /api/auth/[...nextauth] (login)
  NA-->>U: Set-Cookie(session) ou JWT
  U->>API: PUT /api/enrollments/{id} (cookies envoyés)
  API->>NA: auth() / getServerSession()
  API-->>U: 200 si rôle autorisé
```

---

## Récap des endpoints d’auth à exposer selon l’option (côté Next)

| Endpoint                       | JWT “maison” | Clerk            | NextAuth                          |
| ------------------------------ | ------------ | ---------------- | --------------------------------- |
| `POST /api/auth/register`      | ✔︎           | ✖︎ (Clerk UI)    | ✖︎ (NextAuth UI/providers)        |
| `POST /api/auth/login`         | ✔︎           | ✖︎               | ✖︎ (via `[...nextauth]`)          |
| `POST /api/auth/refresh`       | ✔︎           | ✖︎               | ✖︎ (NextAuth gère la session/JWT) |
| `POST /api/auth/logout`        | ✔︎           | ✖︎               | ✖︎ (via `[...nextauth]`)          |
| `POST /api/auth/revoke`        | ✔︎           | ✖︎               | ✖︎                                |
| `POST /api/auth/validate`      | ✔︎           | ✔︎ (vérif Clerk) | ✔︎ (vérif session/JWT NextAuth)   |
| `GET  /api/auth/me`            | ✔︎           | ✔︎               | ✔︎                                |
| `POST /api/webhooks/clerk`     | ✖︎           | ✔︎ (optionnel)   | ✖︎                                |
| `GET  /api/auth/[...nextauth]` | ✖︎           | ✖︎               | ✔︎ (route NextAuth)               |

---

## Erreurs & sécurité (communes)

* **401 Unauthorized** : session absente / token invalide / expiré.
* **403 Forbidden** : session valide mais rôle insuffisant.
* **CORS** : autoriser l’origine de votre front si vous servez l’API sur domaine séparé.
* **Cookies** : toujours **HttpOnly + Secure** en prod.
* **Horloges** : manipuler UTC pour les dates.
* **JWKS caching** (Clerk / JWT RS256 NextAuth) recommandé.

**Format d’erreur JSON conseillé**

```json
{
  "status": 403,
  "error": "Forbidden",
  "message": "Access denied for role Student on /api/courses (DELETE)."
}
```

---

## Diagramme global (comparatif Next)

```mermaid
graph TB
  subgraph API["Next.js App Router (API)"]
    P1[Guard: StudentOnly]
    P2[Guard: InstructorOrAdmin]
    P3[Guard: AdminOnly]
  end

  subgraph A["Option A: JWT maison"]
    A1[/api/auth/register|login|refresh|logout|revoke|validate|me]
    A2[Cookies HttpOnly / Bearer]
  end

  subgraph B["Option B: Clerk"]
    B1[Sign-in/Sign-up UI Clerk]
    B2[currentUser()/auth()]
    B3[/api/webhooks/clerk (sync)]
  end

  subgraph C["Option C: NextAuth"]
    C1[[...nextauth] route]
    C2[auth()/getServerSession()]
    C3[JWT optionnel pour clients externes]
  end

  A2 --> API
  B2 --> API
  C2 --> API
```

---

## Conseils de choix rapide

* **Simple, full-stack Next, contrôle total** : **JWT “maison”**
* **Besoin d’une solution d’identité gérée (MFA, UI, providers)** : **Clerk**
* **Déjà en Next avec providers variés, logique côté front** : **NextAuth**

